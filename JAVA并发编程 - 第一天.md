一.并发简述
    <1>优点：
        1.发挥多处理能力
        2.使建模简单化
        3.使异步处理简单化
        4.响应更加灵敏
    <2>缺点：
        1.线程安全性风险
            a.原因：
                a)多线程环境下
                b)多线程共享一个资源时
                c)对资源进行读写操作
        2.活跃性问题（死锁、活锁、饥饿）
            a.多个线程有共享的资源，且都不释放资源，导致多个线程无法执行
            b.多个线程有共享的资源，且都释放资源，导致多个线程无法执行
            c.饥饿触发的情况：
                a)低优先级线程一直轮不到执行,高优先级吞噬低优先级的CPU时间片；
                b)线程被永久阻塞在一个等待进入同步块的状态，等待的线程永远不被唤醒
                c)线程可以通过方法设置优先级
                d)尽量避免饥饿：设置合理优先级；使用自定义的锁代替synchronized；
        3.性能问题
            a.一般情况下多线程会提高性能
            b.cpu上下文调度时，多线程会降低性能
            c.时间片：为了保证所有进程可以得到公平调度,CPU时间片被划分为一段段的时间片,这些时间片再被轮流分配给各个进程。这样,当某个进程的时间片耗尽了,就会被系统挂起,切换到其他正在等待CPU的进程运行
            d.上下文调度：进程在系统资源不足(比如内存不足)时，需要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行，当进程通过随眠函数sleep这样的方法将自己主动挂起时，自然也会重新调度
                a)前后俩个线程属于不同进程，此时，由于资源不共享，所以切换过程就跟进程上下文切换是一样的
                b)前后两个线程属于同一个进程，此时，应为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据，寄存器等不共享的数据

二.线程状态 - 生命周期
    1.start  线程刚刚被实例化
    2.ready-to-run 线程已经准备就绪，当拿到运行资源后进入到（running）中
    3.running 线程运行中
    4.dead 线程终止
    5.sleeping 线程进入睡眠状态，通过<Thread.sleep();>方法触发
    6.waiting 线程进入等待状态，通过<Object.wait();>方法触发，进入此状态后需要通过<Object.notify();>/<Object.notifyAll();>方法唤醒线程
    7.Blocked 线程阻塞状态
    8.Runnable是任务，Thread线程开启需要调用start（）方法实例化，同时在创建实例时设置<任务>

三.创建线程的方式
    <1>继承自Thread类：
        1.重写run();方法
        1.(.setDaeman(true);) 守护线程方法
        2.(.interrupt();) 中断线程方法（JDK6.0以上的新方法，推荐），使用前需要在线程中通过(interrupted()，返回boolean类型)根据需求在指定位置调用，然后在需要的时候调用中断方法
    <2>实现Runnable接口：
        1.实现接口，重写run();方法，创建Thread类对象，实例化过程中设置任务（当前实现Runnable接口的对象）
    <3>通过匿名内部类的方式
        1.匿名内部类需要父类或者接口实现，本质使没有名称的类，主要在只创建一次对象的时候使用
        2.通过重写子类run();方法
            <new Thread(){
                public void run(){
                };
            }.start();>
        3.通过接口实现，重写run();方法
            <new Thread(new Runnable(){
                public void run(){
                }
            }).start();>
        4.两种方式同时使用时，只执行子类重写的run()方法
    <4>通过实现Callable接口，重写call();方法(需要设置返回值类型)，创建带返回值的线程
    <5>通过创建定时器创建线程<new Timer();>
        1.(.schedule();) 创建定时任务方法
    <6>使用线程池创建线程（Executor接口）
        1.通过调用Executors的方法（多个方法、不同参数）创建实例，（不同方法创建不同的线程池）
        2.通过(.execute();)方法创建线程任务
        3.通过(.shutdown();)停止线程池
    <7>使用Spring Jar包 创建线程
    <8>使用Lambda表达式创建线程（JDK8以上的新方法）
        1.(.Stream())普通流
        2.(.parallelStream())并发流
