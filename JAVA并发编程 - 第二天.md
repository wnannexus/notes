四.解决安全性问题
    <1>Synchronized原理
        1.内置锁：每一个Java中对象都有内置锁，线程在进入同步代码块之前都需要先获得内置锁
        2.内置锁是一个互斥锁
        3.互斥锁：同一时间最多只有一个线程能获得该锁，其他尝试获取该锁的线程必须等待或阻塞，直到锁被使用的线程释放
        4.Synchronized修饰普通方法时，内置锁属于当前类的实例对象
        5.Synchronized修饰静态方法时，内置锁属于当前的Class字节码对象
        6.Synchronized修饰代码块，内置锁时属于指定的对象
        7.JAVA虚拟机执行同步代码块时，通过进入和退出monitor对象来实现方法同步
        8.monitorenter：字节码指令 进入monitor对象
        9.monitorexit：字节码指令 退出monitor对象
        10.内置锁会被自动释放，无论时正常释放还是异常释放
        11.锁存在于对象头中
        12.对象头中的信息：
            a.Mark Word(锁存在于此信息中)
            b.Class Metadata Address
            c.Array Length
        13.偏向锁：偏向锁采用等待竞争出现才释放锁的机制
            a.一个线程访问偏向锁时，对象头信息会返回线程ID以及锁标志位（用于判断是哪种锁），如果线程D等于当前线程ID，则不需要重复获取锁的步骤，避免浪费资源
        14.轻量级锁：多个线程可以同时获得，减少无实际竞争情况下，使用重量级锁产生的性能消耗
        15.重量级锁：
    <2>单例模式
        1.饿汉式：单例类创建时先实例化，没有线程安全性问题
        2.懒汉式：单例类创建时没有实例化，使用时再实例化，双重检查加锁，解决线程安全性问题
    <3>volatile关键字
        1.被修饰的变量对象，在线程之间可见；一个线程修改了变量，另一个线程可以读到修改后的值
    <4>AtomicInteger：JDK5新特性，原子操作
    <5>Lock接口：（通过对Synchronized进行封装实现的）
        1.Lock需要显式获取和释放锁，Synchronized是隐式获取和释放锁
        2.可以方便实现公平性
        3.可以非阻塞的获取锁
        4.可以中断获取锁
        5.可以超时获取锁
    <6>AbstractQueuedSynchronizer(AQS):JDK5以上的新特性（有官方文档查看）
    <7>公平锁：公平是针对锁的获取而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序
    <8>重入锁：重进入是指任意线程在获取到锁之后，再次获取该锁不会被该锁阻塞
    <9>读写锁：读锁是共享锁，写锁是排他锁
        1.排他锁同一时刻只允许一个线程访问
        2.保存的状态：
            a.写锁重入次数
            b.读锁的个数
            c.每个读锁重入的个数
        3.锁降级：写锁降级到读锁，写锁未释放时，获取到读锁，再释放写锁
        4.锁升级：读锁升级到写锁，读锁未释放时，获取到写锁，再释放读锁
    <10>总结：
        1.解决途径：
            a.synchronized （偏向锁，轻量级锁，重量级锁）
            b.volatile
            c.JDK提供的原子类
            d.使用Lock(锁)（共享锁，排它锁）
        2.锁类型：
            a.偏向锁
            b.轻量级锁
            c.重量级锁
            e.重入锁
            f.自旋锁
            g.共享锁
            h.独占锁
            i.排他锁
            j.读写锁
            k.公平锁
            l.非公平锁
            m.死锁
            n.活锁
